---
layout:     post
title:      FlowRadar简介
subtitle:   FlowRadar原理
date:       2018-10-29
author:     Valiant
header-img: img/post-bg-cook.jpg
catalog: true
tags:
---

# FlowRadar

1. 解决的问题

   ​	NetFlow是目前广泛使用的网络监控工具，它将流数据保存在哈希表中，可以支持流的插入、碰撞处理和流的移除。由于数据中心中商用交换机对于包处理速度的限制，很难将所有流都保存在哈希表中，因此许多NetFlow的功能和其他的监控方案都需要对流数据进行采样或者选择流数据的一个子集进行监控。然而数据中心网络对于所有流的实时统计和监控的需求越来越强，我们需要覆盖所有的流数据去捕获那些仅仅发生在小部分流上的瞬时的环路、黑洞和交换机故障以实现网络传输分析。FlowRadar是一种利用较小的存储空间和带宽统计流数量的方法，它使用较小的存储开销保存了所有流的计数信息，并且可以在很短时间内输出这些信息，因此对于数据中心中需要统计所有流信息的监控应用是一种很好的解决方案。

2. 系统结构
![FlowRadar Architecture](./FlowRadar_Architecture.png)

​	上图是FlowRadar系统的结构，FlowRadar由记录流数量的交换机和远端分析系统组成。各个交换机记录通过本交换的流数量信息，并且使用FlowRadar的编码算法对这些流和其计数信息进行编码，编码操作可以在固定的时间内完成，并且编码后的信息仅占用较小的固定存储空间，这样可以不通过采样而保存所有流的信息，并且周期性地将这些编码信息传输到远端的分析系统。远端的分析系统具有很强的计算能力，可以将各个交换机上传的编码流信息快速解码并根据不同的监控目的对流数据进行处理分析。

3. 更新算法

   ![IBLT based flow counters](./IBLT_based_flow_counters.png)

   ​	交换机编码信息的数据结构如上图所示，包括两个部分：第一个部分是流过滤器，流过滤器是一个普通的布隆过滤器，用来测试新来的数据包属于已记录的流还是新的流，即通过流过滤器的几个哈希函数将数据包流信息映射的位置处置1；第二个部分是用来存储流信息的计数表，计数表的每个单元格包含三个域：

   - 流异或：存储映射到此单元格中所有流的异或值

   - 流计数：存储映射到此单元格中流的数量

   - 数据包计数：存储映射到此单元格的所有数据包数量

     ![FlowRadar packet processing algorithm](./FlowRadar_packet_processing_algorithm.png)

   ​	更新算法如上图所示，当一个新的数据包到达之后，首先使用流过滤器判断该数据包是否是属于新的流，若是新的流，则将流过滤器中的对应的单元格置1，然后使用流计数器的数个哈希函数将流计数器中对应的单元格中的流异或域和数据包计数器进行更新；若是已存在的流，则只需将流计数器中对应的单元格中数据包计数器进行更新。

4. 查询算法

   ​	远端的处理系统收到编码后的流数据后需要对流数据进行解码，首先处理系统找出那些只包含一个流的单元格（称为“基础单元”）。对于在基础单元中的流，使用流计数器的哈希函数找出其所在的其他单元格，在这些单元格中去除掉该流的信息（将基础流和这些单元格中的流异或域进行异或操作，减掉数据包计数器相应的数值并将流计数器的值减1），操作完成后继续寻找基础单元，并且重复相同的操作直到没有基础单元。然而由于网络中的流量会出现突变，这样会导致在单一解码过程中很容易出现没有基础单元的情况。为了解决流量爆发的问题，FlowRadar算法提出了一种在整个网络范围内解码的方案，网络范围解码分为两步：在交换机之间交叉解码流信息；在单一交换机内解码技术信息。

   交叉解码流信息：

   ​	相邻的交换机之间必然包含一部分相同的流信息，因此我们可以通过这部分相同的流信息对两个交换机中的流编码信息进行交叉解码。

   ![Flow Decode Algorithm] (./Flow_Decode_Algorithm.png)

   ​	解码算法如上图所示，假设我们有N个编码流数据集合：$A_1..A_N$，和通过单一交换机解码得到的流集合$S_1..S_N$。对于任意两个相邻交换机的数据集$A_i$和$A_j$，找出$A_i$中解码出而$A_j$ 中未解码出的共有流，并将这些流信息从 $A_j$ 的流过滤器中移除，然后再次使用单一交换机解码算法对所有流数据集进行处理，得到新的解码流集合$S_1..S_N$ 并且继续检查相邻编码数据集中的共有流数据，然后重复进行交叉解码和单一解码直到无法进行解码。

   单一交换机解码计数信息：

   ​	虽然通过交叉解码可以很容易解码出流信息，但是由于数据包丢失和一些正在传输过程中的数据包，相邻交换机之间的计数信息可能不同，因此无法通过这种方法解码计数信息。由于我们已经获得了每个交换机上的所有流，可以通过建立线性方程组的方式计算出流的计数值。具体来说，在每一个单元格上，我们已知出现在此单元格的流和总的数据包数量，这样就可以根据数据包数量在每一个单元格上建立一个方程组$CountTable[i].PacketCount=  \sum_{\forall f,\exists j,H^C_j(f)=i}f.PacketCount$ 。 假设有$m_c$个单元格和$n$ 个流，则我们就可以构建一个 $m_c$	个方程$n$ 个变量的方程组，通过解这个矩阵方程$MX=b$ ，我们就可以计算出流计数值。
